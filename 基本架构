Flink的整个系统主要由两个组件构成，分别为JobManager和TaskManager， Flink架构也遵循Master-Slave架构设计原则， JobManager为Worker（Slave）节点。所有组件之间的通信都是借助于Akka Freamwork，
包括任务的状态以及Checkpoint触发等信息。

## Client客户端
客户端负责将任务提交到集群，与JobManager构建Akka连接，然后将任务提交到JobManager，通过和JobManager之间进行交互获取任务执行状态。客户端提交任务可以采用CLI方式或者通过使用Flink WebUI提交，
也可以在应用程序中指定JobManager的RPC网络端口构建ExecutionEnvironment提交Flink应用。

## JobManager
JobManager负责整个Flink集群任务的调度以及资源的管理，从客户端中获取提交的应用，然后根据集群中TaskManager上TaskSlot的使用情况，为提交的应用分配相应的TaskSlots资源并命令TaskManager启动从客户端
获取的应用。 JobManager相当于整个集群的Master节点，且整个集群有且仅有一个活跃的JobManager，负责整个集群的任务管理和资源管理。
JobManager和TaskManager通过Actor System进行通信，获取任务执行的情况并通过Actor System将应用的任务执行情况发送给客户端。同时在任务执行过程中，Flink JobManager会触发Checkpoints操作，每个
TaskManager节点收到Checkpoint触发指令后，完成Checkpoint操作，所有的Checkpoint协调过程都是在Flink JobManager中完成。 当任务完成后，Flink会将任务执行的信息反馈给客户端，并且释放掉TaskManager
中的资源以供下一次提交任务使用。

## TaskManager
TaskManager相当于整个集群的Slave节点，负责具体的任务执行和对应任务在每个节点上的资源申请与管理。客户端通过将编写好的Flink应用编译打包，提交到JobManager，然后JobManager会根据已经注册在JobManager
中TaskManager的资源情况，将任务分配给有资源的TaskManager节点，然后启动并运行任务。 TaskManager从JobManager接收需要部署的任务，然后使用Slot资源去启动Task，建立数据接入的网络连接，接收数据并
开始数据处理。同时TaskManager之间的数据交互都是通过数据流的方式进行的。

可以看出，Flink的任务运行其实是采用多线程的方式，这和Mapreduce多JVM进程的方式由很大的区别。 Flink能够极大的提高CPU的使用效率，在多个任务和Task之间通过TaskSlot方式共享系统资源，每个TaskManager
中通过管理多个TaskSlot资源池进行对资源进行有效管理。
